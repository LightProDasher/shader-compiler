From 7c43220f0fc931617686d530b56f498dfee397d9 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Fri, 21 Oct 2022 22:57:10 +0100
Subject: [PATCH 11/14] Switch subgroup operations to use the Vulkan 1.1 API
 over the extension

Suport for the Vulkan 1.1 API is now more prevalent than support for the extension itself.
---
 backend/spirv/emit_spirv.cpp      |  8 ++++----
 backend/spirv/emit_spirv_warp.cpp | 26 +++++++++++++++-----------
 2 files changed, 19 insertions(+), 15 deletions(-)

diff --git a/backend/spirv/emit_spirv.cpp b/backend/spirv/emit_spirv.cpp
index 265ac9c..04ae314 100644
--- a/backend/spirv/emit_spirv.cpp
+++ b/backend/spirv/emit_spirv.cpp
@@ -426,12 +426,12 @@ void SetupCapabilities(const Profile& profile, const Info& info, EmitContext& ct
     if ((info.uses_subgroup_vote || info.uses_subgroup_invocation_id ||
          info.uses_subgroup_shuffles) &&
         profile.support_vote) {
-        ctx.AddExtension("SPV_KHR_shader_ballot");
-        ctx.AddCapability(spv::Capability::SubgroupBallotKHR);
+        ctx.AddCapability(spv::Capability::GroupNonUniformBallot);
+        ctx.AddCapability(spv::Capability::GroupNonUniformShuffle);
+
         if (!profile.warp_size_potentially_larger_than_guest) {
             // vote ops are only used when not taking the long path
-            ctx.AddExtension("SPV_KHR_subgroup_vote");
-            ctx.AddCapability(spv::Capability::SubgroupVoteKHR);
+            ctx.AddCapability(spv::Capability::GroupNonUniformVote);
         }
     }
     if (info.uses_int64_bit_atomics && profile.support_int64_atomics) {
diff --git a/backend/spirv/emit_spirv_warp.cpp b/backend/spirv/emit_spirv_warp.cpp
index 7cbbbfa..f9ecc51 100644
--- a/backend/spirv/emit_spirv_warp.cpp
+++ b/backend/spirv/emit_spirv_warp.cpp
@@ -6,6 +6,10 @@
 
 namespace Shader::Backend::SPIRV {
 namespace {
+Id SubgroupScope(EmitContext& ctx) {
+    return ctx.Const(static_cast<u32>(spv::Scope::Subgroup));
+}
+
 Id GetThreadId(EmitContext& ctx) {
     return ctx.OpLoad(ctx.U32[1], ctx.subgroup_local_invocation_id);
 }
@@ -50,7 +54,7 @@ Id GetMaxThreadId(EmitContext& ctx, Id thread_id, Id clamp, Id segmentation_mask
 
 Id SelectValue(EmitContext& ctx, Id in_range, Id value, Id src_thread_id) {
     return ctx.OpSelect(ctx.U32[1], in_range,
-                        ctx.OpSubgroupReadInvocationKHR(ctx.U32[1], value, src_thread_id), value);
+                        ctx.OpGroupNonUniformShuffle(ctx.U32[1], SubgroupScope(ctx), value, src_thread_id), value);
 }
 
 Id GetUpperClamp(EmitContext& ctx, Id invocation_id, Id clamp) {
@@ -71,40 +75,40 @@ Id EmitLaneId(EmitContext& ctx) {
 
 Id EmitVoteAll(EmitContext& ctx, Id pred) {
     if (!ctx.profile.warp_size_potentially_larger_than_guest) {
-        return ctx.OpSubgroupAllKHR(ctx.U1, pred);
+        return ctx.OpGroupNonUniformAll(ctx.U1, SubgroupScope(ctx), pred);
     }
-    const Id mask_ballot{ctx.OpSubgroupBallotKHR(ctx.U32[4], ctx.true_value)};
+    const Id mask_ballot{ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), ctx.true_value)};
     const Id active_mask{WarpExtract(ctx, mask_ballot)};
-    const Id ballot{WarpExtract(ctx, ctx.OpSubgroupBallotKHR(ctx.U32[4], pred))};
+    const Id ballot{WarpExtract(ctx, ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), pred))};
     const Id lhs{ctx.OpBitwiseAnd(ctx.U32[1], ballot, active_mask)};
     return ctx.OpIEqual(ctx.U1, lhs, active_mask);
 }
 
 Id EmitVoteAny(EmitContext& ctx, Id pred) {
     if (!ctx.profile.warp_size_potentially_larger_than_guest) {
-        return ctx.OpSubgroupAnyKHR(ctx.U1, pred);
+        return ctx.OpGroupNonUniformAny(ctx.U1, SubgroupScope(ctx), pred);
     }
-    const Id mask_ballot{ctx.OpSubgroupBallotKHR(ctx.U32[4], ctx.true_value)};
+    const Id mask_ballot{ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), ctx.true_value)};
     const Id active_mask{WarpExtract(ctx, mask_ballot)};
-    const Id ballot{WarpExtract(ctx, ctx.OpSubgroupBallotKHR(ctx.U32[4], pred))};
+    const Id ballot{WarpExtract(ctx, ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), pred))};
     const Id lhs{ctx.OpBitwiseAnd(ctx.U32[1], ballot, active_mask)};
     return ctx.OpINotEqual(ctx.U1, lhs, ctx.u32_zero_value);
 }
 
 Id EmitVoteEqual(EmitContext& ctx, Id pred) {
     if (!ctx.profile.warp_size_potentially_larger_than_guest) {
-        return ctx.OpSubgroupAllEqualKHR(ctx.U1, pred);
+        return ctx.OpGroupNonUniformAllEqual(ctx.U1, SubgroupScope(ctx), pred);
     }
-    const Id mask_ballot{ctx.OpSubgroupBallotKHR(ctx.U32[4], ctx.true_value)};
+    const Id mask_ballot{ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), ctx.true_value)};
     const Id active_mask{WarpExtract(ctx, mask_ballot)};
-    const Id ballot{WarpExtract(ctx, ctx.OpSubgroupBallotKHR(ctx.U32[4], pred))};
+    const Id ballot{WarpExtract(ctx, ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), pred))};
     const Id lhs{ctx.OpBitwiseXor(ctx.U32[1], ballot, active_mask)};
     return ctx.OpLogicalOr(ctx.U1, ctx.OpIEqual(ctx.U1, lhs, ctx.u32_zero_value),
                            ctx.OpIEqual(ctx.U1, lhs, active_mask));
 }
 
 Id EmitSubgroupBallot(EmitContext& ctx, Id pred) {
-    const Id ballot{ctx.OpSubgroupBallotKHR(ctx.U32[4], pred)};
+    const Id ballot{ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), pred)};
     if (!ctx.profile.warp_size_potentially_larger_than_guest) {
         return ctx.OpCompositeExtract(ctx.U32[1], ballot, 0U);
     }
-- 
2.38.1

