From 219129c05d5b9442e1fc5be10f9101b6a1e2b203 Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Fri, 21 Oct 2022 22:57:10 +0100
Subject: [PATCH 11/14] Switch subgroup operations to use the Vulkan 1.1 API
 over the extension

Suport for the Vulkan 1.1 API is now more prevalent than support for the extension itself.
---
 backend/spirv/emit_spirv.cpp      | 22 +++++++++++-----------
 backend/spirv/emit_spirv_warp.cpp | 30 +++++++++++++++++-------------
 2 files changed, 28 insertions(+), 24 deletions(-)

diff --git a/backend/spirv/emit_spirv.cpp b/backend/spirv/emit_spirv.cpp
index 265ac9c..695f668 100644
--- a/backend/spirv/emit_spirv.cpp
+++ b/backend/spirv/emit_spirv.cpp
@@ -7,12 +7,12 @@
 #include <utility>
 #include <vector>
 
-#include "common/settings.h"
-#include "shader_recompiler/backend/spirv/emit_spirv.h"
-#include "shader_recompiler/backend/spirv/emit_spirv_instructions.h"
-#include "shader_recompiler/backend/spirv/spirv_emit_context.h"
-#include "shader_recompiler/frontend/ir/basic_block.h"
-#include "shader_recompiler/frontend/ir/program.h"
+#include <shader_compiler/common/settings.h>
+#include <shader_compiler/backend/spirv/emit_spirv.h>
+#include <shader_compiler/backend/spirv/emit_spirv_instructions.h>
+#include <shader_compiler/backend/spirv/spirv_emit_context.h>
+#include <shader_compiler/frontend/ir/basic_block.h>
+#include <shader_compiler/frontend/ir/program.h>
 
 namespace Shader::Backend::SPIRV {
 namespace {
@@ -100,7 +100,7 @@ void EmitInst(EmitContext& ctx, IR::Inst* inst) {
 #define OPCODE(name, result_type, ...)                                                             \
     case IR::Opcode::name:                                                                         \
         return Invoke<&Emit##name>(ctx, inst);
-#include "shader_recompiler/frontend/ir/opcodes.inc"
+#include <shader_compiler/frontend/ir/opcodes.inc>
 #undef OPCODE
     }
     throw LogicError("Invalid opcode {}", inst->GetOpcode());
@@ -426,12 +426,12 @@ void SetupCapabilities(const Profile& profile, const Info& info, EmitContext& ct
     if ((info.uses_subgroup_vote || info.uses_subgroup_invocation_id ||
          info.uses_subgroup_shuffles) &&
         profile.support_vote) {
-        ctx.AddExtension("SPV_KHR_shader_ballot");
-        ctx.AddCapability(spv::Capability::SubgroupBallotKHR);
+        ctx.AddCapability(spv::Capability::GroupNonUniformBallot);
+        ctx.AddCapability(spv::Capability::GroupNonUniformShuffle);
+
         if (!profile.warp_size_potentially_larger_than_guest) {
             // vote ops are only used when not taking the long path
-            ctx.AddExtension("SPV_KHR_subgroup_vote");
-            ctx.AddCapability(spv::Capability::SubgroupVoteKHR);
+            ctx.AddCapability(spv::Capability::GroupNonUniformVote);
         }
     }
     if (info.uses_int64_bit_atomics && profile.support_int64_atomics) {
diff --git a/backend/spirv/emit_spirv_warp.cpp b/backend/spirv/emit_spirv_warp.cpp
index 7cbbbfa..a7bebac 100644
--- a/backend/spirv/emit_spirv_warp.cpp
+++ b/backend/spirv/emit_spirv_warp.cpp
@@ -1,11 +1,15 @@
 // SPDX-FileCopyrightText: Copyright 2021 yuzu Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "shader_recompiler/backend/spirv/emit_spirv_instructions.h"
-#include "shader_recompiler/backend/spirv/spirv_emit_context.h"
+#include <shader_compiler/backend/spirv/emit_spirv_instructions.h>
+#include <shader_compiler/backend/spirv/spirv_emit_context.h>
 
 namespace Shader::Backend::SPIRV {
 namespace {
+Id SubgroupScope(EmitContext& ctx) {
+    return ctx.Const(static_cast<u32>(spv::Scope::Subgroup));
+}
+
 Id GetThreadId(EmitContext& ctx) {
     return ctx.OpLoad(ctx.U32[1], ctx.subgroup_local_invocation_id);
 }
@@ -50,7 +54,7 @@ Id GetMaxThreadId(EmitContext& ctx, Id thread_id, Id clamp, Id segmentation_mask
 
 Id SelectValue(EmitContext& ctx, Id in_range, Id value, Id src_thread_id) {
     return ctx.OpSelect(ctx.U32[1], in_range,
-                        ctx.OpSubgroupReadInvocationKHR(ctx.U32[1], value, src_thread_id), value);
+                        ctx.OpGroupNonUniformShuffle(ctx.U32[1], SubgroupScope(ctx), value, src_thread_id), value);
 }
 
 Id GetUpperClamp(EmitContext& ctx, Id invocation_id, Id clamp) {
@@ -71,40 +75,40 @@ Id EmitLaneId(EmitContext& ctx) {
 
 Id EmitVoteAll(EmitContext& ctx, Id pred) {
     if (!ctx.profile.warp_size_potentially_larger_than_guest) {
-        return ctx.OpSubgroupAllKHR(ctx.U1, pred);
+        return ctx.OpGroupNonUniformAll(ctx.U1, SubgroupScope(ctx), pred);
     }
-    const Id mask_ballot{ctx.OpSubgroupBallotKHR(ctx.U32[4], ctx.true_value)};
+    const Id mask_ballot{ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), ctx.true_value)};
     const Id active_mask{WarpExtract(ctx, mask_ballot)};
-    const Id ballot{WarpExtract(ctx, ctx.OpSubgroupBallotKHR(ctx.U32[4], pred))};
+    const Id ballot{WarpExtract(ctx, ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), pred))};
     const Id lhs{ctx.OpBitwiseAnd(ctx.U32[1], ballot, active_mask)};
     return ctx.OpIEqual(ctx.U1, lhs, active_mask);
 }
 
 Id EmitVoteAny(EmitContext& ctx, Id pred) {
     if (!ctx.profile.warp_size_potentially_larger_than_guest) {
-        return ctx.OpSubgroupAnyKHR(ctx.U1, pred);
+        return ctx.OpGroupNonUniformAny(ctx.U1, SubgroupScope(ctx), pred);
     }
-    const Id mask_ballot{ctx.OpSubgroupBallotKHR(ctx.U32[4], ctx.true_value)};
+    const Id mask_ballot{ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), ctx.true_value)};
     const Id active_mask{WarpExtract(ctx, mask_ballot)};
-    const Id ballot{WarpExtract(ctx, ctx.OpSubgroupBallotKHR(ctx.U32[4], pred))};
+    const Id ballot{WarpExtract(ctx, ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), pred))};
     const Id lhs{ctx.OpBitwiseAnd(ctx.U32[1], ballot, active_mask)};
     return ctx.OpINotEqual(ctx.U1, lhs, ctx.u32_zero_value);
 }
 
 Id EmitVoteEqual(EmitContext& ctx, Id pred) {
     if (!ctx.profile.warp_size_potentially_larger_than_guest) {
-        return ctx.OpSubgroupAllEqualKHR(ctx.U1, pred);
+        return ctx.OpGroupNonUniformAllEqual(ctx.U1, SubgroupScope(ctx), pred);
     }
-    const Id mask_ballot{ctx.OpSubgroupBallotKHR(ctx.U32[4], ctx.true_value)};
+    const Id mask_ballot{ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), ctx.true_value)};
     const Id active_mask{WarpExtract(ctx, mask_ballot)};
-    const Id ballot{WarpExtract(ctx, ctx.OpSubgroupBallotKHR(ctx.U32[4], pred))};
+    const Id ballot{WarpExtract(ctx, ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), pred))};
     const Id lhs{ctx.OpBitwiseXor(ctx.U32[1], ballot, active_mask)};
     return ctx.OpLogicalOr(ctx.U1, ctx.OpIEqual(ctx.U1, lhs, ctx.u32_zero_value),
                            ctx.OpIEqual(ctx.U1, lhs, active_mask));
 }
 
 Id EmitSubgroupBallot(EmitContext& ctx, Id pred) {
-    const Id ballot{ctx.OpSubgroupBallotKHR(ctx.U32[4], pred)};
+    const Id ballot{ctx.OpGroupNonUniformBallot(ctx.U32[4], SubgroupScope(ctx), pred)};
     if (!ctx.profile.warp_size_potentially_larger_than_guest) {
         return ctx.OpCompositeExtract(ctx.U32[1], ballot, 0U);
     }
-- 
2.38.1

